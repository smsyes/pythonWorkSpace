(dp0
Vid
p1
V3bf2d24988be0c
p2
sVname
p3
VFlattenMdelbyUV
p4
sVinfo
p5
VUV\ub97c \uba54\uc26c\ub85c \ubcc0\ud658
p6
sVtags
p7
Vscript
p8
sVicon
p9
V
p10
sVcommand
p11
V//--------------------------------------------------------------------------\u000a//\u000a// ScriptName : flatten Model By UV\u000a// Contents   : select faces of mesh based on edgeloops\u000a// Author     : Joe Wu\u000a// URL        : https://www.youtube.com/@Im3dJoe\u000a// Since      : 2022/10\u000a// Version    : 1.00 public release\u000a//--------------------------------------------------------------------------\u000a\u000aglobal proc flattenModelbyUV(){\u000a    $scaleMethod = 0;\u000a    //scale method, 0 use random edge  - fast but not accurate\u000a    //              1 use boundry box  - fast also not accurate\u000a    //              2 use longest edge - slow but more accurate\u000a    string $SLobj[] = `ls -sl -fl` ;\u000a        if (`size $SLobj` > 0){\u000a            for ($A=0;$A<`size $SLobj`;$A++){\u000a                if (`match "BlendShape" $SLobj[$A]` != "BlendShape"){\u000a                    string $BlendShape1 , $BlendShape2 ;\u000a                    select -r $SLobj[$A] ;\u000a                    string $TempNameA[] = `duplicate -n ($SLobj[$A]+"_BlendShape1")` ;\u000a                    $BlendShape1 = $TempNameA[0] ;\u000a                    polySoftEdge -a 0 -ch 1 $BlendShape1;FreezeTransformations;DeleteHistory;\u000a                    PolySelectConvert 4;polySelectBorderShell 1;SplitVertex;\u000a                    select -r $BlendShape1 ;FreezeTransformations;DeleteHistory;\u000a                    string $TempName[] = `duplicate -n ($SLobj[$A]+"_BlendShape2")` ; $BlendShape2 = $TempName[0] ;\u000a                    int $VtxNum[] = `polyEvaluate -v`;\u000a                    for ($B=0;$B<$VtxNum[0];$B++){\u000a                        string $VTXname = $BlendShape2 + ".vtx[" + $B + "]" ;\u000a                        float $UVnum[] = `polyEvaluate -bc2 $VTXname`;\u000a                        move ($UVnum[0]-0.5) 0 (0.5-$UVnum[2]) $VTXname;\u000a                        }\u000a                    select -r $BlendShape2 ;\u000a                    CenterPivot $BlendShape2;\u000a                    //scale\u000a                    //no boader Edge, cause problem when find max length\u000a                    select -r $SLobj[$A] ;\u000a                    string $currSelected[] = `ls -sl -o`;\u000a                    string $tempAAA[] = `ls ($currSelected[0]+".map[*]")`;\u000a                    select $tempAAA;\u000a                    polySelectBorderShell 1;\u000a                    PolySelectConvert 20;\u000a                    string $potentialEdges[]=`filterExpand -ex 1 -sm 32`;\u000a                    string $removedEdges[];\u000a                    clear $removedEdges;\u000a                    for($eachEdge in $potentialEdges){\u000a                            string $uvs[] =`polyListComponentConversion -fe -tuv $eachEdge`;\u000a                            $uvs = `ls -fl $uvs`;\u000a                            if(size($uvs)<=2)\u000a                                    $removedEdges[size($removedEdges)] = $eachEdge;\u000a                    }\u000a                    if (`size($removedEdges)` !=  `size($potentialEdges)`){\u000a                        select -d $removedEdges;\u000a                        InvertSelection;\u000a                        }\u000a                    float $scaleFactorRef;\u000a                    if($scaleMethod == 0){\u000a                        string $amountOfEdge[]= `ls -sl -fl`;\u000a                        float $value;\u000a                        $targetEdge = $amountOfEdge[`size$amountOfEdge`/2];\u000a                        select -r $targetEdge;\u000a                        select -r `polyListComponentConversion -tv`;\u000a                        string $connectedVerts[] = `filterExpand -ex 1 -sm 31`;\u000a                        vector $PT1 = `pointPosition -w $connectedVerts[0]`;\u000a                        vector $PT2 = `pointPosition -w $connectedVerts[1]`;\u000a                        float $distance3d = mag($PT1-$PT2);\u000a                        string $buffer[];\u000a                        tokenize $targetEdge "." $buffer;\u000a                        select ($BlendShape2+"."+$buffer[1]);\u000a                        $edge=`ls -sl`;\u000a                        string $tmp[] =`polyListComponentConversion -fe -tv $edge[0]`;\u000a                        string $vtx[]=`ls -fl $tmp`;\u000a                        vector $p1 =`pointPosition -w $vtx[0]`;\u000a                        vector $p2=`pointPosition -w $vtx[1]`;\u000a                        $distance3dB = mag($p2-$p1);\u000a                        $scaleFactorRef =$distance3d/ $distance3dB;\u000a                        \u000a                        }\u000a                    else if ($scaleMethod == 1){\u000a                        float $area3DA[] = `polyEvaluate -b ($SLobj[$A]+"_BlendShape1")`;\u000a                        float $area2DA[] = `polyEvaluate -b ($SLobj[$A]+"_BlendShape2")`;\u000a                        float $XXXAA = sqrt(($area3DA[3]-$area3DA[0])*($area3DA[3]-$area3DA[0]));\u000a                        float $ZZZAA = sqrt(($area3DA[5]-$area3DA[2])*($area3DA[5]-$area3DA[2]));\u000a                        if($XXXAA < $ZZZAA){\u000a                            $XXXAA =  $ZZZAA;\u000a                        }\u000a                        float $XXXBB = sqrt(($area2DA[3]-$area2DA[0])*($area2DA[3]-$area2DA[0]));\u000a                        float $ZZZBB = sqrt(($area2DA[5]-$area2DA[2])*($area2DA[5]-$area2DA[2]));\u000a                        if($XXXBB < $ZZZBB){\u000a                            $XXXBB =  $ZZZBB;\u000a                        }\u000a                        $scaleFactorRef = $XXXAA/ $XXXBB;\u000a                    }\u000a                    else{\u000a                        string $amountOfEdge[]= `ls -sl -fl`;\u000a                        float $value;\u000a                        $value=0;\u000a                        string $targetEdge;\u000a                        for($i=0;$i<`size $amountOfEdge`;$i++){\u000a                                select -r $amountOfEdge[$i];\u000a                                select -r `polyListComponentConversion -tv`;\u000a                                string $connectedVerts[] = `filterExpand -ex 1 -sm 31`;\u000a                                vector $PT1 = `pointPosition -w $connectedVerts[0]`;\u000a                                vector $PT2 = `pointPosition -w $connectedVerts[1]`;\u000a                                float $checkEdgeLength = mag($PT1-$PT2);\u000a                                if( $checkEdgeLength > $value){\u000a                                    $value = $checkEdgeLength;\u000a                                    $targetEdge = $amountOfEdge[$i];\u000a                                    }\u000a                                }\u000a                         select $targetEdge;\u000a                        //distance Oringal\u000a                        $distance3d = $value;\u000a                        //distance flatten\u000a                        string $buffer[];\u000a                        tokenize $targetEdge "." $buffer;\u000a                        select ($BlendShape2+"."+$buffer[1]);\u000a                        $edge=`ls -sl`;\u000a                        string $tmp[] =`polyListComponentConversion -fe -tv $edge[0]`;\u000a                        string $vtx[]=`ls -fl $tmp`;\u000a                        vector $p1 =`pointPosition -w $vtx[0]`;\u000a                        vector $p2=`pointPosition -w $vtx[1]`;\u000a                        $distance3dB = mag($p2-$p1);\u000a                        $scaleFactorRef =$distance3d/ $distance3dB;\u000a                    }\u000a                    setAttr ($BlendShape2+".scaleX")  $scaleFactorRef;\u000a                    setAttr ($BlendShape2+".scaleY")  $scaleFactorRef;\u000a                    setAttr ($BlendShape2+".scaleZ")  $scaleFactorRef;\u000a                    select -r $BlendShape2;\u000a                    FreezeTransformations;\u000a                    string $BlandName[] = `blendShape $BlendShape2 $BlendShape1`;\u000a                    addAttr -ln FlattenModel -at double  -min 0 -max 1 -dv 0 ("|" + $BlendShape1);setAttr -e -keyable true ("|" + $BlendShape1 + ".FlattenModel");\u000a                    expression -s ($BlandName[0] + "." + $BlendShape2 + " = " + $BlendShape1 + ".FlattenModel")  -o pCube1_BlendShape1 -ae 1 -uc all ;\u000a                    rename $BlendShape1 ($SLobj[$A] +"FlattenModel");\u000a                    delete $BlendShape2;\u000a                    currentTime 1 ;\u000a                    setKeyframe ($SLobj[$A]  + "FlattenModel.FlattenModel");\u000a                    currentTime 25 ;\u000a                    setAttr ($SLobj[$A]  + "FlattenModel.FlattenModel") 1;\u000a                    setKeyframe ($SLobj[$A]  + "FlattenModel.FlattenModel");\u000a\u000a\u000a					// fix broken merge\u000a					select $SLobj[$A] ;\u000a					float $myBB[] = `xform -q -bb -ws`;\u000a					ConvertSelectionToUVs;\u000a					$tempShell = `texGetShells`; // type is string[]\u000a					for ($t in $tempShell){\u000a						$cmd = ("select " + $t);\u000a						eval $cmd;\u000a						ConvertSelectionToContainedFaces;\u000a						string $shellFace[]=`ls -sl -fl`;\u000a						string $flattenUVFace[];\u000a						clear $flattenUVFace;\u000a						for  ($s in $shellFace){\u000a							string $tempShellName = `substitute $SLobj[$A]  $s ($SLobj[$A] +"FlattenModel")`;\u000a							 $flattenUVFace[size( $flattenUVFace)] =$tempShellName;\u000a							 }\u000a						select $flattenUVFace;\u000a						polyMergeVertex  -d 0.001 -am 1;\u000a						select $flattenUVFace;\u000a						polyMergeUV -d 0.001;\u000a						}\u000a					select -r ($SLobj[$A] +"FlattenModel");\u000a					float $newBB[] = `xform -q -bb -ws`;\u000a					float $moveSide = ($newBB[3] - $newBB[0])/2 + ($myBB[3] - $myBB[0]) ;\u000a					move -r -os -wd  $moveSide 0 0;\u000a					currentTime 25;\u000a					SetToFaceNormals;\u000a				}\u000a			}\u000a        }\u000a    select("*FlattenModel");\u000a    }\u000aflattenModelbyUV;
p12
sVsyntax
p13
Vmel
p14
s.